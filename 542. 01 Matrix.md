Wow. This problem sucked. Originally I had the right idea for a DP solution but I didn't update the ones in place and that skewed the values on start.

Anyway, find the distance from top left to bottom right, and update the min distance, then do the same from the bottome right to the top left.
```Java
class Solution {
    public int[][] updateMatrix(int[][] mat) {
        for(int x = 0; x < mat.length; x++){
            for(int y = 0; y < mat[0].length; y++){
                if(mat[x][y] == 0){
                    mat[x][y] = 0;
                }else{
                    mat[x][y] = Integer.MAX_VALUE-100;
                }
            }
        }

        for(int x = 0; x < mat.length; x++){
            for(int y = 0; y < mat[0].length; y++){
                if(mat[x][y] == 0){
                    mat[x][y] = 0;
                }else{
                    mat[x][y] = minNeighbors(mat, x, y);
                }
            }
        }
            
        for(int x = mat.length-1; x >= 0; x--){
            for(int y = mat[0].length-1; y >= 0; y--){
                if(mat[x][y] == 0){
                    mat[x][y] = 0;
                }else{
                    mat[x][y] = minNeighbors(mat, x, y);
                }
            }
        }

        return mat;
    
    }
    
    int minNeighbors(int[][] mat, int x, int y){
        int l1 = 10000, l2 = 10000, l3 = 10000, l4 = 10000;
        if(!(x <= 0)){
            l1 = mat[x-1][y];
        }
        
        if(!(y <= 0)){
            l2 = mat[x][y-1];
        }
        
        if(!(x >= mat.length-1)){
            l3 = mat[x+1][y];
        }
        
        if(!(y >= mat[0].length-1)){
            l4 = mat[x][y+1];
        }
        
        return Math.min(l1, Math.min(l2, Math.min(l3, l4)))+1;
    }
}
```
Runtime: 11 ms, faster than 80.06% of Java online submissions for 01 Matrix.

Memory Usage: 68.3 MB, less than 77.16% of Java online submissions for 01 Matrix.

