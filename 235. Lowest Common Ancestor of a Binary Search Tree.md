```Java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */

//Look for both items at the same time, the second one node isnt equal to the other return the former node
//Essentially two binary searches
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        TreeNode pFind = root, qFind = root, common = root;
        
        while(pFind.equals(qFind)){
            common = pFind;
            if(pFind.equals(p) || qFind.equals(q)){
                return pFind;   
            }
            
            
            if(pFind.val > p.val){
                pFind = pFind.left;
            }else{
                pFind = pFind.right;
            }
            
            if(qFind.val > q.val){
                qFind = qFind.left;
            }else{
                qFind = qFind.right;
            }
            
            
        }
        
        return common;
    }
}
```
Runtime: 5 ms, faster than 81.15% of Java online submissions for Lowest Common Ancestor of a Binary Search Tree.

Memory Usage: 50.2 MB, less than 33.07% of Java online submissions for Lowest Common Ancestor of a Binary Search Tree.
